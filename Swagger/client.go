// Package Swagger provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package Swagger

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
)

// App defines model for App.
type App struct {
	AllowSurge   *AllowSurge   `json:"allowSurge,omitempty"`
	CustomDomain *CustomDomain `json:"customDomain,omitempty"`
	DockerImage  *DockerImage  `json:"dockerImage,omitempty"`
	HttpPort     *HttpPort     `json:"httpPort,omitempty"`
	MaxScaling   *MaxScaling   `json:"maxScaling,omitempty"`
	MinScaling   *MinScaling   `json:"minScaling,omitempty"`
	Name         *AppName      `json:"name,omitempty"`
	PodSize      *PodSize      `json:"podSize,omitempty"`
	ServiceUrl   *ServiceUrl   `json:"serviceUrl,omitempty"`
	Url          *string       `json:"url,omitempty"`
}

// Env defines model for Env.
type Env struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// AllowSurge defines model for allowSurge.
type AllowSurge bool

// ApiKey defines model for apiKey.
type ApiKey string

// AppName defines model for appName.
type AppName string

// AppStatus defines model for appStatus.
type AppStatus struct {
	Certs *struct {
		CustomDomain *CertStatus `json:"customDomain,omitempty"`
	} `json:"certs,omitempty"`
	Pods *[]PodStatus `json:"pods,omitempty"`
}

// Body defines model for body.
type Body struct {
	AllowSurge   *AllowSurge   `json:"allowSurge,omitempty"`
	CustomDomain *CustomDomain `json:"customDomain,omitempty"`
	DockerImage  *DockerImage  `json:"dockerImage,omitempty"`
	HttpPort     *HttpPort     `json:"httpPort,omitempty"`
	MaxScaling   *MaxScaling   `json:"maxScaling,omitempty"`
	MinScaling   *MinScaling   `json:"minScaling,omitempty"`
	PodSize      *PodSize      `json:"podSize,omitempty"`
}

// Body1 defines model for body_1.
type Body1 struct {
	HttpPort HttpPort `json:"httpPort"`
	Name     *AppName `json:"name,omitempty"`
}

// BodyCert defines model for body_cert.
type BodyCert struct {
	ApiKey ApiKey       `json:"apiKey"`
	Domain CustomDomain `json:"domain"`
	Email  Email        `json:"email"`
	Type   Type         `json:"type"`
}

// BodyEnv defines model for body_env.
type BodyEnv struct {
	REDISPASSWORD *string `json:"REDIS_PASSWORD,omitempty"`
}

// CertStatus defines model for certStatus.
type CertStatus struct {
	Domain *string `json:"domain,omitempty"`
	Ready  *string `json:"ready,omitempty"`
	Status *string `json:"status,omitempty"`
}

// CreateApp defines model for createApp.
type CreateApp struct {
	Name *AppName `json:"name,omitempty"`
}

// CustomDomain defines model for customDomain.
type CustomDomain string

// DockerCredentials defines model for dockerCredentials.
type DockerCredentials struct {
	CliCommand *string   `json:"cliCommand,omitempty"`
	Login      *Username `json:"login,omitempty"`
	Password   *string   `json:"password,omitempty"`
	Repo       *string   `json:"repo,omitempty"`
}

// DockerImage defines model for dockerImage.
type DockerImage string

// Email defines model for email.
type Email string

// HttpPort defines model for httpPort.
type HttpPort int64

// MaxScaling defines model for maxScaling.
type MaxScaling int

// MinScaling defines model for minScaling.
type MinScaling int

// MinutesBehind defines model for minutesBehind.
type MinutesBehind int64

// PodSize defines model for podSize.
type PodSize string

// PodStatus defines model for podStatus.
type PodStatus struct {
	Created *string `json:"created,omitempty"`
	Name    *string `json:"name,omitempty"`
	Status  *string `json:"status,omitempty"`
}

// ServiceUrl defines model for serviceUrl.
type ServiceUrl string

// Step defines model for step.
type Step int64

// Success defines model for success.
type Success struct {
	Success *bool `json:"success,omitempty"`
}

// Type defines model for type.
type Type string

// Username defines model for username.
type Username string

// Values defines model for values.
type Values [][]string

// Volume defines model for volume.
type Volume struct {
	Class  *string `json:"class,omitempty"`
	Path   *string `json:"path,omitempty"`
	SizeGB *int    `json:"sizeGB,omitempty"`
}

// VolumeGet defines model for volumeGet.
type VolumeGet struct {
	Class  *string     `json:"class,omitempty"`
	Name   *VolumeName `json:"name,omitempty"`
	Path   *string     `json:"path,omitempty"`
	SizeGB *int        `json:"sizeGB,omitempty"`
}

// VolumeName defines model for volumeName.
type VolumeName string

// Volumes defines model for volumes.
type Volumes []VolumeGet

// createAppJSONBody defines parameters for CreateApp.
type createAppJSONBody Body1

// updateAppJSONBody defines parameters for UpdateApp.
type updateAppJSONBody Body

// updateAppEnvJSONBody defines parameters for UpdateAppEnv.
type updateAppEnvJSONBody BodyEnv

// createAppVolumesJSONBody defines parameters for CreateAppVolumes.
type createAppVolumesJSONBody Volume

// createCertJSONBody defines parameters for CreateCert.
type createCertJSONBody BodyCert

// CreateAppRequestBody defines body for CreateApp for application/json ContentType.
type CreateAppJSONRequestBody createAppJSONBody

// UpdateAppRequestBody defines body for UpdateApp for application/json ContentType.
type UpdateAppJSONRequestBody updateAppJSONBody

// UpdateAppEnvRequestBody defines body for UpdateAppEnv for application/json ContentType.
type UpdateAppEnvJSONRequestBody updateAppEnvJSONBody

// CreateAppVolumesRequestBody defines body for CreateAppVolumes for application/json ContentType.
type CreateAppVolumesJSONRequestBody createAppVolumesJSONBody

// CreateCertRequestBody defines body for CreateCert for application/json ContentType.
type CreateCertJSONRequestBody createCertJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(req *http.Request, ctx context.Context) error

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// HTTP client with any customized settings, such as certificate chains.
	Client http.Client

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllApps request
	GetAllApps(ctx context.Context) (*http.Response, error)

	// CreateApp request  with any body
	CreateAppWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateApp(ctx context.Context, body CreateAppJSONRequestBody) (*http.Response, error)

	// DeleteApp request
	DeleteApp(ctx context.Context, appName AppName) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, appName AppName) (*http.Response, error)

	// UpdateApp request  with any body
	UpdateAppWithBody(ctx context.Context, appName AppName, contentType string, body io.Reader) (*http.Response, error)

	UpdateApp(ctx context.Context, appName AppName, body UpdateAppJSONRequestBody) (*http.Response, error)

	// GetAppEnv request
	GetAppEnv(ctx context.Context, appName AppName) (*http.Response, error)

	// UpdateAppEnv request  with any body
	UpdateAppEnvWithBody(ctx context.Context, appName AppName, contentType string, body io.Reader) (*http.Response, error)

	UpdateAppEnv(ctx context.Context, appName AppName, body UpdateAppEnvJSONRequestBody) (*http.Response, error)

	// GetAppLogs request
	GetAppLogs(ctx context.Context, appName AppName) (*http.Response, error)

	// ReleaseApp request
	ReleaseApp(ctx context.Context, appName AppName) (*http.Response, error)

	// GetAppStatus request
	GetAppStatus(ctx context.Context, appName AppName) (*http.Response, error)

	// GetAppVolumes request
	GetAppVolumes(ctx context.Context, appName AppName) (*http.Response, error)

	// CreateAppVolumes request  with any body
	CreateAppVolumesWithBody(ctx context.Context, appName AppName, contentType string, body io.Reader) (*http.Response, error)

	CreateAppVolumes(ctx context.Context, appName AppName, body CreateAppVolumesJSONRequestBody) (*http.Response, error)

	// DeleteAppVolume request
	DeleteAppVolume(ctx context.Context, appName AppName, volumeName VolumeName) (*http.Response, error)

	// GetAppCpuUsage request
	GetAppCpuUsage(ctx context.Context, appName AppName, minutesBehind MinutesBehind, step Step) (*http.Response, error)

	// GetAppMemoryUsage request
	GetAppMemoryUsage(ctx context.Context, appName AppName, minutesBehind MinutesBehind, step Step) (*http.Response, error)

	// CreateCert request  with any body
	CreateCertWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	CreateCert(ctx context.Context, body CreateCertJSONRequestBody) (*http.Response, error)

	// GetDockerCredentials request
	GetDockerCredentials(ctx context.Context) (*http.Response, error)
}

func (c *Client) GetAllApps(ctx context.Context) (*http.Response, error) {
	req, err := NewGetAllAppsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateAppRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApp(ctx context.Context, body CreateAppJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateAppRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApp(ctx context.Context, appName AppName) (*http.Response, error) {
	req, err := NewDeleteAppRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetApp(ctx context.Context, appName AppName) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppWithBody(ctx context.Context, appName AppName, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateAppRequestWithBody(c.Server, appName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApp(ctx context.Context, appName AppName, body UpdateAppJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateAppRequest(c.Server, appName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppEnv(ctx context.Context, appName AppName) (*http.Response, error) {
	req, err := NewGetAppEnvRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppEnvWithBody(ctx context.Context, appName AppName, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateAppEnvRequestWithBody(c.Server, appName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppEnv(ctx context.Context, appName AppName, body UpdateAppEnvJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateAppEnvRequest(c.Server, appName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppLogs(ctx context.Context, appName AppName) (*http.Response, error) {
	req, err := NewGetAppLogsRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseApp(ctx context.Context, appName AppName) (*http.Response, error) {
	req, err := NewReleaseAppRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppStatus(ctx context.Context, appName AppName) (*http.Response, error) {
	req, err := NewGetAppStatusRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppVolumes(ctx context.Context, appName AppName) (*http.Response, error) {
	req, err := NewGetAppVolumesRequest(c.Server, appName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppVolumesWithBody(ctx context.Context, appName AppName, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateAppVolumesRequestWithBody(c.Server, appName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppVolumes(ctx context.Context, appName AppName, body CreateAppVolumesJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateAppVolumesRequest(c.Server, appName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppVolume(ctx context.Context, appName AppName, volumeName VolumeName) (*http.Response, error) {
	req, err := NewDeleteAppVolumeRequest(c.Server, appName, volumeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppCpuUsage(ctx context.Context, appName AppName, minutesBehind MinutesBehind, step Step) (*http.Response, error) {
	req, err := NewGetAppCpuUsageRequest(c.Server, appName, minutesBehind, step)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppMemoryUsage(ctx context.Context, appName AppName, minutesBehind MinutesBehind, step Step) (*http.Response, error) {
	req, err := NewGetAppMemoryUsageRequest(c.Server, appName, minutesBehind, step)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCertWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewCreateCertRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCert(ctx context.Context, body CreateCertJSONRequestBody) (*http.Response, error) {
	req, err := NewCreateCertRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetDockerCredentials(ctx context.Context) (*http.Response, error) {
	req, err := NewGetDockerCredentialsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewGetAllAppsRequest generates requests for GetAllApps
func NewGetAllAppsRequest(server string) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/v1/apps", server)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAppRequest calls the generic CreateApp builder with application/json body
func NewCreateAppRequest(server string, body CreateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAppRequestWithBody generates requests for CreateApp with any type of body
func NewCreateAppRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/v1/apps", server)

	req, err := http.NewRequest("POST", queryUrl, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteAppRequest generates requests for DeleteApp
func NewDeleteAppRequest(server string, appName AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s", server, pathParam0)

	req, err := http.NewRequest("DELETE", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, appName AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s", server, pathParam0)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppRequest calls the generic UpdateApp builder with application/json body
func NewUpdateAppRequest(server string, appName AppName, body UpdateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppRequestWithBody(server, appName, "application/json", bodyReader)
}

// NewUpdateAppRequestWithBody generates requests for UpdateApp with any type of body
func NewUpdateAppRequestWithBody(server string, appName AppName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s", server, pathParam0)

	req, err := http.NewRequest("PUT", queryUrl, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetAppEnvRequest generates requests for GetAppEnv
func NewGetAppEnvRequest(server string, appName AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s/env", server, pathParam0)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppEnvRequest calls the generic UpdateAppEnv builder with application/json body
func NewUpdateAppEnvRequest(server string, appName AppName, body UpdateAppEnvJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppEnvRequestWithBody(server, appName, "application/json", bodyReader)
}

// NewUpdateAppEnvRequestWithBody generates requests for UpdateAppEnv with any type of body
func NewUpdateAppEnvRequestWithBody(server string, appName AppName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s/env", server, pathParam0)

	req, err := http.NewRequest("PUT", queryUrl, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetAppLogsRequest generates requests for GetAppLogs
func NewGetAppLogsRequest(server string, appName AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s/logs", server, pathParam0)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReleaseAppRequest generates requests for ReleaseApp
func NewReleaseAppRequest(server string, appName AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s/release", server, pathParam0)

	req, err := http.NewRequest("POST", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppStatusRequest generates requests for GetAppStatus
func NewGetAppStatusRequest(server string, appName AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s/status", server, pathParam0)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppVolumesRequest generates requests for GetAppVolumes
func NewGetAppVolumesRequest(server string, appName AppName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s/volumes", server, pathParam0)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAppVolumesRequest calls the generic CreateAppVolumes builder with application/json body
func NewCreateAppVolumesRequest(server string, appName AppName, body CreateAppVolumesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppVolumesRequestWithBody(server, appName, "application/json", bodyReader)
}

// NewCreateAppVolumesRequestWithBody generates requests for CreateAppVolumes with any type of body
func NewCreateAppVolumesRequestWithBody(server string, appName AppName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s/volumes", server, pathParam0)

	req, err := http.NewRequest("POST", queryUrl, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewDeleteAppVolumeRequest generates requests for DeleteAppVolume
func NewDeleteAppVolumeRequest(server string, appName AppName, volumeName VolumeName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "volumeName", volumeName)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s/volumes/%s", server, pathParam0, pathParam1)

	req, err := http.NewRequest("DELETE", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppCpuUsageRequest generates requests for GetAppCpuUsage
func NewGetAppCpuUsageRequest(server string, appName AppName, minutesBehind MinutesBehind, step Step) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "minutesBehind", minutesBehind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "step", step)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s/%s/%s/cpu", server, pathParam0, pathParam1, pathParam2)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppMemoryUsageRequest generates requests for GetAppMemoryUsage
func NewGetAppMemoryUsageRequest(server string, appName AppName, minutesBehind MinutesBehind, step Step) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "appName", appName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "minutesBehind", minutesBehind)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "step", step)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/v1/apps/%s/%s/%s/memory", server, pathParam0, pathParam1, pathParam2)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCertRequest calls the generic CreateCert builder with application/json body
func NewCreateCertRequest(server string, body CreateCertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCertRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCertRequestWithBody generates requests for CreateCert with any type of body
func NewCreateCertRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/v1/cert", server)

	req, err := http.NewRequest("POST", queryUrl, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetDockerCredentialsRequest generates requests for GetDockerCredentials
func NewGetDockerCredentialsRequest(server string) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/v1/dockerCredentials", server)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses returns a ClientWithResponses with a default Client:
func NewClientWithResponses(server string) *ClientWithResponses {
	return &ClientWithResponses{
		ClientInterface: &Client{
			Client: http.Client{},
			Server: server,
		},
	}
}

// NewClientWithResponsesAndRequestEditorFunc takes in a RequestEditorFn callback function and returns a ClientWithResponses with a default Client:
func NewClientWithResponsesAndRequestEditorFunc(server string, reqEditorFn RequestEditorFn) *ClientWithResponses {
	return &ClientWithResponses{
		ClientInterface: &Client{
			Client:        http.Client{},
			Server:        server,
			RequestEditor: reqEditorFn,
		},
	}
}

type getAllAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Apps *[]App `json:"apps,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r getAllAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getAllAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateApp
}

// Status returns HTTPResponse.Status
func (r createAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
}

// Status returns HTTPResponse.Status
func (r deleteAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		App *App `json:"app,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r getAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
}

// Status returns HTTPResponse.Status
func (r updateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getAppEnvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Env
}

// Status returns HTTPResponse.Status
func (r getAppEnvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getAppEnvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateAppEnvResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
}

// Status returns HTTPResponse.Status
func (r updateAppEnvResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateAppEnvResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getAppLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r getAppLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getAppLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type releaseAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
}

// Status returns HTTPResponse.Status
func (r releaseAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r releaseAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getAppStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStatus
}

// Status returns HTTPResponse.Status
func (r getAppStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getAppStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getAppVolumesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Volumes *Volumes `json:"volumes,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r getAppVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getAppVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createAppVolumesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
}

// Status returns HTTPResponse.Status
func (r createAppVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createAppVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type deleteAppVolumeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
}

// Status returns HTTPResponse.Status
func (r deleteAppVolumeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r deleteAppVolumeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getAppCpuUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Values
}

// Status returns HTTPResponse.Status
func (r getAppCpuUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getAppCpuUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getAppMemoryUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Values
}

// Status returns HTTPResponse.Status
func (r getAppMemoryUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getAppMemoryUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type createCertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Success
}

// Status returns HTTPResponse.Status
func (r createCertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r createCertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getDockerCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DockerCredentials
}

// Status returns HTTPResponse.Status
func (r getDockerCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getDockerCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllAppsWithResponse request returning *GetAllAppsResponse
func (c *ClientWithResponses) GetAllAppsWithResponse(ctx context.Context) (*getAllAppsResponse, error) {
	rsp, err := c.GetAllApps(ctx)
	if err != nil {
		return nil, err
	}
	return ParsegetAllAppsResponse(rsp)
}

// CreateAppWithBodyWithResponse request with arbitrary body returning *CreateAppResponse
func (c *ClientWithResponses) CreateAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createAppResponse, error) {
	rsp, err := c.CreateAppWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsecreateAppResponse(rsp)
}

func (c *ClientWithResponses) CreateAppWithResponse(ctx context.Context, body CreateAppJSONRequestBody) (*createAppResponse, error) {
	rsp, err := c.CreateApp(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsecreateAppResponse(rsp)
}

// DeleteAppWithResponse request returning *DeleteAppResponse
func (c *ClientWithResponses) DeleteAppWithResponse(ctx context.Context, appName AppName) (*deleteAppResponse, error) {
	rsp, err := c.DeleteApp(ctx, appName)
	if err != nil {
		return nil, err
	}
	return ParsedeleteAppResponse(rsp)
}

// GetAppWithResponse request returning *GetAppResponse
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, appName AppName) (*getAppResponse, error) {
	rsp, err := c.GetApp(ctx, appName)
	if err != nil {
		return nil, err
	}
	return ParsegetAppResponse(rsp)
}

// UpdateAppWithBodyWithResponse request with arbitrary body returning *UpdateAppResponse
func (c *ClientWithResponses) UpdateAppWithBodyWithResponse(ctx context.Context, appName AppName, contentType string, body io.Reader) (*updateAppResponse, error) {
	rsp, err := c.UpdateAppWithBody(ctx, appName, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseupdateAppResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppWithResponse(ctx context.Context, appName AppName, body UpdateAppJSONRequestBody) (*updateAppResponse, error) {
	rsp, err := c.UpdateApp(ctx, appName, body)
	if err != nil {
		return nil, err
	}
	return ParseupdateAppResponse(rsp)
}

// GetAppEnvWithResponse request returning *GetAppEnvResponse
func (c *ClientWithResponses) GetAppEnvWithResponse(ctx context.Context, appName AppName) (*getAppEnvResponse, error) {
	rsp, err := c.GetAppEnv(ctx, appName)
	if err != nil {
		return nil, err
	}
	return ParsegetAppEnvResponse(rsp)
}

// UpdateAppEnvWithBodyWithResponse request with arbitrary body returning *UpdateAppEnvResponse
func (c *ClientWithResponses) UpdateAppEnvWithBodyWithResponse(ctx context.Context, appName AppName, contentType string, body io.Reader) (*updateAppEnvResponse, error) {
	rsp, err := c.UpdateAppEnvWithBody(ctx, appName, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseupdateAppEnvResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppEnvWithResponse(ctx context.Context, appName AppName, body UpdateAppEnvJSONRequestBody) (*updateAppEnvResponse, error) {
	rsp, err := c.UpdateAppEnv(ctx, appName, body)
	if err != nil {
		return nil, err
	}
	return ParseupdateAppEnvResponse(rsp)
}

// GetAppLogsWithResponse request returning *GetAppLogsResponse
func (c *ClientWithResponses) GetAppLogsWithResponse(ctx context.Context, appName AppName) (*getAppLogsResponse, error) {
	rsp, err := c.GetAppLogs(ctx, appName)
	if err != nil {
		return nil, err
	}
	return ParsegetAppLogsResponse(rsp)
}

// ReleaseAppWithResponse request returning *ReleaseAppResponse
func (c *ClientWithResponses) ReleaseAppWithResponse(ctx context.Context, appName AppName) (*releaseAppResponse, error) {
	rsp, err := c.ReleaseApp(ctx, appName)
	if err != nil {
		return nil, err
	}
	return ParsereleaseAppResponse(rsp)
}

// GetAppStatusWithResponse request returning *GetAppStatusResponse
func (c *ClientWithResponses) GetAppStatusWithResponse(ctx context.Context, appName AppName) (*getAppStatusResponse, error) {
	rsp, err := c.GetAppStatus(ctx, appName)
	if err != nil {
		return nil, err
	}
	return ParsegetAppStatusResponse(rsp)
}

// GetAppVolumesWithResponse request returning *GetAppVolumesResponse
func (c *ClientWithResponses) GetAppVolumesWithResponse(ctx context.Context, appName AppName) (*getAppVolumesResponse, error) {
	rsp, err := c.GetAppVolumes(ctx, appName)
	if err != nil {
		return nil, err
	}
	return ParsegetAppVolumesResponse(rsp)
}

// CreateAppVolumesWithBodyWithResponse request with arbitrary body returning *CreateAppVolumesResponse
func (c *ClientWithResponses) CreateAppVolumesWithBodyWithResponse(ctx context.Context, appName AppName, contentType string, body io.Reader) (*createAppVolumesResponse, error) {
	rsp, err := c.CreateAppVolumesWithBody(ctx, appName, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsecreateAppVolumesResponse(rsp)
}

func (c *ClientWithResponses) CreateAppVolumesWithResponse(ctx context.Context, appName AppName, body CreateAppVolumesJSONRequestBody) (*createAppVolumesResponse, error) {
	rsp, err := c.CreateAppVolumes(ctx, appName, body)
	if err != nil {
		return nil, err
	}
	return ParsecreateAppVolumesResponse(rsp)
}

// DeleteAppVolumeWithResponse request returning *DeleteAppVolumeResponse
func (c *ClientWithResponses) DeleteAppVolumeWithResponse(ctx context.Context, appName AppName, volumeName VolumeName) (*deleteAppVolumeResponse, error) {
	rsp, err := c.DeleteAppVolume(ctx, appName, volumeName)
	if err != nil {
		return nil, err
	}
	return ParsedeleteAppVolumeResponse(rsp)
}

// GetAppCpuUsageWithResponse request returning *GetAppCpuUsageResponse
func (c *ClientWithResponses) GetAppCpuUsageWithResponse(ctx context.Context, appName AppName, minutesBehind MinutesBehind, step Step) (*getAppCpuUsageResponse, error) {
	rsp, err := c.GetAppCpuUsage(ctx, appName, minutesBehind, step)
	if err != nil {
		return nil, err
	}
	return ParsegetAppCpuUsageResponse(rsp)
}

// GetAppMemoryUsageWithResponse request returning *GetAppMemoryUsageResponse
func (c *ClientWithResponses) GetAppMemoryUsageWithResponse(ctx context.Context, appName AppName, minutesBehind MinutesBehind, step Step) (*getAppMemoryUsageResponse, error) {
	rsp, err := c.GetAppMemoryUsage(ctx, appName, minutesBehind, step)
	if err != nil {
		return nil, err
	}
	return ParsegetAppMemoryUsageResponse(rsp)
}

// CreateCertWithBodyWithResponse request with arbitrary body returning *CreateCertResponse
func (c *ClientWithResponses) CreateCertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*createCertResponse, error) {
	rsp, err := c.CreateCertWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsecreateCertResponse(rsp)
}

func (c *ClientWithResponses) CreateCertWithResponse(ctx context.Context, body CreateCertJSONRequestBody) (*createCertResponse, error) {
	rsp, err := c.CreateCert(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsecreateCertResponse(rsp)
}

// GetDockerCredentialsWithResponse request returning *GetDockerCredentialsResponse
func (c *ClientWithResponses) GetDockerCredentialsWithResponse(ctx context.Context) (*getDockerCredentialsResponse, error) {
	rsp, err := c.GetDockerCredentials(ctx)
	if err != nil {
		return nil, err
	}
	return ParsegetDockerCredentialsResponse(rsp)
}

// ParsegetAllAppsResponse parses an HTTP response from a GetAllAppsWithResponse call
func ParsegetAllAppsResponse(rsp *http.Response) (*getAllAppsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getAllAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			Apps *[]App `json:"apps,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParsecreateAppResponse parses an HTTP response from a CreateAppWithResponse call
func ParsecreateAppResponse(rsp *http.Response) (*createAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		response.JSON201 = &CreateApp{}
		if err := json.Unmarshal(bodyBytes, response.JSON201); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsedeleteAppResponse parses an HTTP response from a DeleteAppWithResponse call
func ParsedeleteAppResponse(rsp *http.Response) (*deleteAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Success{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsegetAppResponse parses an HTTP response from a GetAppWithResponse call
func ParsegetAppResponse(rsp *http.Response) (*getAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			App *App `json:"app,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParseupdateAppResponse parses an HTTP response from a UpdateAppWithResponse call
func ParseupdateAppResponse(rsp *http.Response) (*updateAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Success{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsegetAppEnvResponse parses an HTTP response from a GetAppEnvWithResponse call
func ParsegetAppEnvResponse(rsp *http.Response) (*getAppEnvResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getAppEnvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &[]Env{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParseupdateAppEnvResponse parses an HTTP response from a UpdateAppEnvWithResponse call
func ParseupdateAppEnvResponse(rsp *http.Response) (*updateAppEnvResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateAppEnvResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Success{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsegetAppLogsResponse parses an HTTP response from a GetAppLogsWithResponse call
func ParsegetAppLogsResponse(rsp *http.Response) (*getAppLogsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getAppLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &[]string{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsereleaseAppResponse parses an HTTP response from a ReleaseAppWithResponse call
func ParsereleaseAppResponse(rsp *http.Response) (*releaseAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &releaseAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Success{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsegetAppStatusResponse parses an HTTP response from a GetAppStatusWithResponse call
func ParsegetAppStatusResponse(rsp *http.Response) (*getAppStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getAppStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &AppStatus{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsegetAppVolumesResponse parses an HTTP response from a GetAppVolumesWithResponse call
func ParsegetAppVolumesResponse(rsp *http.Response) (*getAppVolumesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getAppVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &struct {
			Volumes *Volumes `json:"volumes,omitempty"`
		}{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsecreateAppVolumesResponse parses an HTTP response from a CreateAppVolumesWithResponse call
func ParsecreateAppVolumesResponse(rsp *http.Response) (*createAppVolumesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createAppVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Success{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsedeleteAppVolumeResponse parses an HTTP response from a DeleteAppVolumeWithResponse call
func ParsedeleteAppVolumeResponse(rsp *http.Response) (*deleteAppVolumeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &deleteAppVolumeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Success{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsegetAppCpuUsageResponse parses an HTTP response from a GetAppCpuUsageWithResponse call
func ParsegetAppCpuUsageResponse(rsp *http.Response) (*getAppCpuUsageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getAppCpuUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Values{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsegetAppMemoryUsageResponse parses an HTTP response from a GetAppMemoryUsageWithResponse call
func ParsegetAppMemoryUsageResponse(rsp *http.Response) (*getAppMemoryUsageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getAppMemoryUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Values{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsecreateCertResponse parses an HTTP response from a CreateCertWithResponse call
func ParsecreateCertResponse(rsp *http.Response) (*createCertResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &createCertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Success{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 400:
		break // No content-type
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParsegetDockerCredentialsResponse parses an HTTP response from a GetDockerCredentialsWithResponse call
func ParsegetDockerCredentialsResponse(rsp *http.Response) (*getDockerCredentialsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getDockerCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &DockerCredentials{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get all docker container deployments// (GET /v1/apps)
	GetAllApps(ctx echo.Context) error
	// Create a new docker container deployment// (POST /v1/apps)
	CreateApp(ctx echo.Context) error
	// Delete one docker container deployment// (DELETE /v1/apps/{appName})
	DeleteApp(ctx echo.Context, appName AppName) error
	// Get one docker container deployment// (GET /v1/apps/{appName})
	GetApp(ctx echo.Context, appName AppName) error
	// Updates docker container deployment// (PUT /v1/apps/{appName})
	UpdateApp(ctx echo.Context, appName AppName) error
	// Get env of app// (GET /v1/apps/{appName}/env)
	GetAppEnv(ctx echo.Context, appName AppName) error
	// Update env in app// (PUT /v1/apps/{appName}/env)
	UpdateAppEnv(ctx echo.Context, appName AppName) error
	// Get last docker container deployment logs// (GET /v1/apps/{appName}/logs)
	GetAppLogs(ctx echo.Context, appName AppName) error
	// Release one deployment// (POST /v1/apps/{appName}/release)
	ReleaseApp(ctx echo.Context, appName AppName) error
	// Get status of pods and certificates// (GET /v1/apps/{appName}/status)
	GetAppStatus(ctx echo.Context, appName AppName) error
	// Get volumes of app// (GET /v1/apps/{appName}/volumes)
	GetAppVolumes(ctx echo.Context, appName AppName) error
	// Create volumes in app// (POST /v1/apps/{appName}/volumes)
	CreateAppVolumes(ctx echo.Context, appName AppName) error
	// Delete volume of app// (DELETE /v1/apps/{appName}/volumes/{volumeName})
	DeleteAppVolume(ctx echo.Context, appName AppName, volumeName VolumeName) error
	// Get pod cpu usage// (GET /v1/apps/{appName}/{minutesBehind}/{step}/cpu)
	GetAppCpuUsage(ctx echo.Context, appName AppName, minutesBehind MinutesBehind, step Step) error
	// Get pod memory usage in bytes// (GET /v1/apps/{appName}/{minutesBehind}/{step}/memory)
	GetAppMemoryUsage(ctx echo.Context, appName AppName, minutesBehind MinutesBehind, step Step) error
	// Create certificate in app// (POST /v1/cert)
	CreateCert(ctx echo.Context) error
	// Returns docker login credentials// (GET /v1/dockerCredentials)
	GetDockerCredentials(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAllApps converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllApps(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAllApps(ctx)
	return err
}

// CreateApp converts echo context to params.
func (w *ServerInterfaceWrapper) CreateApp(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateApp(ctx)
	return err
}

// DeleteApp converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteApp(ctx, appName)
	return err
}

// GetApp converts echo context to params.
func (w *ServerInterfaceWrapper) GetApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApp(ctx, appName)
	return err
}

// UpdateApp converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateApp(ctx, appName)
	return err
}

// GetAppEnv converts echo context to params.
func (w *ServerInterfaceWrapper) GetAppEnv(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAppEnv(ctx, appName)
	return err
}

// UpdateAppEnv converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAppEnv(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateAppEnv(ctx, appName)
	return err
}

// GetAppLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetAppLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAppLogs(ctx, appName)
	return err
}

// ReleaseApp converts echo context to params.
func (w *ServerInterfaceWrapper) ReleaseApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ReleaseApp(ctx, appName)
	return err
}

// GetAppStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetAppStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAppStatus(ctx, appName)
	return err
}

// GetAppVolumes converts echo context to params.
func (w *ServerInterfaceWrapper) GetAppVolumes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAppVolumes(ctx, appName)
	return err
}

// CreateAppVolumes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAppVolumes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateAppVolumes(ctx, appName)
	return err
}

// DeleteAppVolume converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAppVolume(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// ------------- Path parameter "volumeName" -------------
	var volumeName VolumeName

	err = runtime.BindStyledParameter("simple", false, "volumeName", ctx.Param("volumeName"), &volumeName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter volumeName: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteAppVolume(ctx, appName, volumeName)
	return err
}

// GetAppCpuUsage converts echo context to params.
func (w *ServerInterfaceWrapper) GetAppCpuUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// ------------- Path parameter "minutesBehind" -------------
	var minutesBehind MinutesBehind

	err = runtime.BindStyledParameter("simple", false, "minutesBehind", ctx.Param("minutesBehind"), &minutesBehind)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minutesBehind: %s", err))
	}

	// ------------- Path parameter "step" -------------
	var step Step

	err = runtime.BindStyledParameter("simple", false, "step", ctx.Param("step"), &step)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter step: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAppCpuUsage(ctx, appName, minutesBehind, step)
	return err
}

// GetAppMemoryUsage converts echo context to params.
func (w *ServerInterfaceWrapper) GetAppMemoryUsage(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "appName" -------------
	var appName AppName

	err = runtime.BindStyledParameter("simple", false, "appName", ctx.Param("appName"), &appName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appName: %s", err))
	}

	// ------------- Path parameter "minutesBehind" -------------
	var minutesBehind MinutesBehind

	err = runtime.BindStyledParameter("simple", false, "minutesBehind", ctx.Param("minutesBehind"), &minutesBehind)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minutesBehind: %s", err))
	}

	// ------------- Path parameter "step" -------------
	var step Step

	err = runtime.BindStyledParameter("simple", false, "step", ctx.Param("step"), &step)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter step: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAppMemoryUsage(ctx, appName, minutesBehind, step)
	return err
}

// CreateCert converts echo context to params.
func (w *ServerInterfaceWrapper) CreateCert(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateCert(ctx)
	return err
}

// GetDockerCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) GetDockerCredentials(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDockerCredentials(ctx)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v1/apps", wrapper.GetAllApps)
	router.POST("/v1/apps", wrapper.CreateApp)
	router.DELETE("/v1/apps/:appName", wrapper.DeleteApp)
	router.GET("/v1/apps/:appName", wrapper.GetApp)
	router.PUT("/v1/apps/:appName", wrapper.UpdateApp)
	router.GET("/v1/apps/:appName/env", wrapper.GetAppEnv)
	router.PUT("/v1/apps/:appName/env", wrapper.UpdateAppEnv)
	router.GET("/v1/apps/:appName/logs", wrapper.GetAppLogs)
	router.POST("/v1/apps/:appName/release", wrapper.ReleaseApp)
	router.GET("/v1/apps/:appName/status", wrapper.GetAppStatus)
	router.GET("/v1/apps/:appName/volumes", wrapper.GetAppVolumes)
	router.POST("/v1/apps/:appName/volumes", wrapper.CreateAppVolumes)
	router.DELETE("/v1/apps/:appName/volumes/:volumeName", wrapper.DeleteAppVolume)
	router.GET("/v1/apps/:appName/:minutesBehind/:step/cpu", wrapper.GetAppCpuUsage)
	router.GET("/v1/apps/:appName/:minutesBehind/:step/memory", wrapper.GetAppMemoryUsage)
	router.POST("/v1/cert", wrapper.CreateCert)
	router.GET("/v1/dockerCredentials", wrapper.GetDockerCredentials)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
